From c7407c37167d2fc703bdd7adf60c83d28f602a91 Mon Sep 17 00:00:00 2001
From: Yong Li <sdliyong@gmail.com>
Date: Thu, 31 Mar 2016 15:33:09 +0800
Subject: [PATCH 07/10] iot2000-hack: gpio-pca953x: add "drive" property

Galileo gen 2 has support for setting GPIO modes. Expose these
properties through the GPIO sysfs interface. This approach is bit hacky,
since it changes the interface semantics.

The original patch was by Josef Ahmad <josef.ahmad@linux.intel.com> and
made on top of kernel 3.8.

Not for upstream.

Signed-off-by: Ismo Puustinen <ismo.puustinen@intel.com>
Signed-off-by: Jussi Laako <jussi.laako@linux.intel.com>
Signed-off-by: Saul Wold <sgw@linux.intel.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: Yong Li <sdliyong@gmail.com>
Signed-off-by: Bruce Ashfield <bruce.ashfield@windriver.com>
Signed-off-by: Jan Kiszka <jan.kiszka@siemens.com>
---
 drivers/gpio/gpio-pca953x.c   | 40 ++++++++++++++++++
 drivers/gpio/gpiolib-sysfs.c  | 77 +++++++++++++++++++++++++++++++++++
 drivers/gpio/gpiolib.c        | 17 ++++++++
 drivers/gpio/gpiolib.h        |  4 ++
 include/asm-generic/gpio.h    |  5 +++
 include/linux/gpio.h          | 10 +++++
 include/linux/gpio/consumer.h | 10 +++++
 include/linux/gpio/driver.h   |  2 +
 8 files changed, 165 insertions(+)

diff --git a/drivers/gpio/gpio-pca953x.c b/drivers/gpio/gpio-pca953x.c
index 51b8a3d5852c..d32efc67f685 100644
--- a/drivers/gpio/gpio-pca953x.c
+++ b/drivers/gpio/gpio-pca953x.c
@@ -456,6 +456,43 @@ static void pca953x_gpio_set_multiple(struct gpio_chip *gc,
 	mutex_unlock(&chip->i2c_lock);
 }
 
+static int pca953x_gpio_set_drive(struct gpio_chip *gc,
+				 unsigned off, unsigned mode)
+{
+	struct pca953x_chip *chip;
+	int ret = 0;
+	int val;
+
+	chip = container_of(gc, struct pca953x_chip, gpio_chip);
+
+	if (!(chip->driver_data & PCA_PCAL))
+		return -EINVAL;
+
+	mutex_lock(&chip->i2c_lock);
+
+	switch (mode) {
+	case GPIOF_DRIVE_PULLUP:
+		ret = pca953x_write_single(chip, PCAL953X_PULL_EN, 1, off) ||
+			pca953x_write_single(chip, PCAL953X_PULL_SEL, 1, off);
+		break;
+	case GPIOF_DRIVE_PULLDOWN:
+		ret = pca953x_write_single(chip, PCAL953X_PULL_EN, 1, off) ||
+			pca953x_write_single(chip, PCAL953X_PULL_SEL, 0, off);
+		break;
+	case GPIOF_DRIVE_STRONG:
+	case GPIOF_DRIVE_HIZ:
+		ret = pca953x_read_single(chip, PCAL953X_PULL_EN, &val, off) ||
+			pca953x_write_single(chip, PCAL953X_PULL_EN, 0, off) ||
+			pca953x_write_single(chip, PCAL953X_PULL_SEL, val, off);
+		break;
+	default:
+		ret = -EINVAL;
+	}
+
+	mutex_unlock(&chip->i2c_lock);
+	return ret;
+}
+
 static void pca953x_setup_gpio(struct pca953x_chip *chip, int gpios)
 {
 	struct gpio_chip *gc;
@@ -476,6 +513,9 @@ static void pca953x_setup_gpio(struct pca953x_chip *chip, int gpios)
 	gc->parent = &chip->client->dev;
 	gc->owner = THIS_MODULE;
 	gc->names = chip->names;
+
+	if (chip->driver_data & PCA_PCAL)
+		gc->set_drive = pca953x_gpio_set_drive;
 }
 
 #ifdef CONFIG_GPIO_PCA953X_IRQ
diff --git a/drivers/gpio/gpiolib-sysfs.c b/drivers/gpio/gpiolib-sysfs.c
index 3dbaf489a8a5..044a57447242 100644
--- a/drivers/gpio/gpiolib-sysfs.c
+++ b/drivers/gpio/gpiolib-sysfs.c
@@ -362,6 +362,82 @@ static ssize_t active_low_store(struct device *dev,
 }
 static DEVICE_ATTR_RW(active_low);
 
+
+static ssize_t gpio_drive_show(struct device *dev,
+		struct device_attribute *attr, char *buf)
+{
+	const struct gpio_desc	*desc = dev_get_drvdata(dev);
+	ssize_t			status;
+
+	mutex_lock(&sysfs_lock);
+
+	if (!test_bit(FLAG_EXPORT, &desc->flags)) {
+		status = -EIO;
+	} else {
+		if (test_bit(FLAG_PULLUP, &desc->flags))
+			status = sprintf(buf, "pullup\n");
+		else if (test_bit(FLAG_PULLDOWN, &desc->flags))
+			status = sprintf(buf, "pulldown\n");
+		else if (test_bit(FLAG_STRONG, &desc->flags))
+			status = sprintf(buf, "strong\n");
+		else if (test_bit(FLAG_HIZ, &desc->flags))
+			status = sprintf(buf, "hiz\n");
+		else
+			status = -EINVAL;
+	}
+
+	mutex_unlock(&sysfs_lock);
+	return status;
+}
+
+static ssize_t gpio_drive_store(struct device *dev,
+		struct device_attribute *attr, const char *buf, size_t size)
+{
+	struct gpio_desc	*desc = dev_get_drvdata(dev);
+	ssize_t			status;
+
+	mutex_lock(&sysfs_lock);
+
+	if (!test_bit(FLAG_EXPORT, &desc->flags))
+		status = -EIO;
+	else {
+		clear_bit(FLAG_PULLUP, &desc->flags);
+		clear_bit(FLAG_PULLDOWN, &desc->flags);
+		clear_bit(FLAG_STRONG, &desc->flags);
+		clear_bit(FLAG_HIZ, &desc->flags);
+		if (sysfs_streq(buf, "pullup")) {
+			status = gpiod_set_drive(desc, GPIOF_DRIVE_PULLUP);
+			if (!status) {
+				set_bit(FLAG_PULLUP, &desc->flags);
+			}
+		} else if (sysfs_streq(buf, "pulldown")) {
+			status = gpiod_set_drive(desc, GPIOF_DRIVE_PULLDOWN);
+			if (!status) {
+				set_bit(FLAG_PULLDOWN, &desc->flags);
+			}
+		} else if (sysfs_streq(buf, "strong")) {
+			status = gpiod_set_drive(desc, GPIOF_DRIVE_STRONG);
+			if (!status) {
+				set_bit(FLAG_STRONG, &desc->flags);
+			}
+		} else if (sysfs_streq(buf, "hiz")) {
+			status = gpiod_set_drive(desc, GPIOF_DRIVE_HIZ);
+			if (!status) {
+				set_bit(FLAG_HIZ, &desc->flags);
+			}
+		} else {
+			status = -EINVAL;
+		}
+	}
+
+	mutex_unlock(&sysfs_lock);
+	return status ? : size;
+}
+
+static DEVICE_ATTR(drive, 0644,
+		gpio_drive_show, gpio_drive_store);
+
+
 static umode_t gpio_is_visible(struct kobject *kobj, struct attribute *attr,
 			       int n)
 {
@@ -389,6 +465,7 @@ static struct attribute *gpio_attrs[] = {
 	&dev_attr_edge.attr,
 	&dev_attr_value.attr,
 	&dev_attr_active_low.attr,
+	&dev_attr_drive.attr,
 	NULL,
 };
 
diff --git a/drivers/gpio/gpiolib.c b/drivers/gpio/gpiolib.c
index 12472b84a71c..a4b470aae60b 100644
--- a/drivers/gpio/gpiolib.c
+++ b/drivers/gpio/gpiolib.c
@@ -2798,6 +2798,23 @@ int gpiod_is_active_low(const struct gpio_desc *desc)
 }
 EXPORT_SYMBOL_GPL(gpiod_is_active_low);
 
+int gpiod_set_drive(struct gpio_desc *desc, unsigned mode)
+{
+	struct gpio_chip	*chip;
+
+	chip = desc->chip;
+	if (!chip || !chip->set || !chip->set_drive)
+		goto fail;
+
+	might_sleep_if(chip->can_sleep);
+
+	return chip->set_drive(chip, gpio_chip_hwgpio(desc), mode);
+
+fail:
+	return -EINVAL;
+}
+EXPORT_SYMBOL_GPL(gpiod_set_drive);
+
 /* I/O calls are only valid after configuration completed; the relevant
  * "is this a valid GPIO" error checks should already have been done.
  *
diff --git a/drivers/gpio/gpiolib.h b/drivers/gpio/gpiolib.h
index a7e49fef73d4..6c3abc5ecbcf 100644
--- a/drivers/gpio/gpiolib.h
+++ b/drivers/gpio/gpiolib.h
@@ -216,6 +216,10 @@ struct gpio_desc {
 #define FLAG_USED_AS_IRQ 9	/* GPIO is connected to an IRQ */
 #define FLAG_IS_HOGGED	11	/* GPIO is hogged */
 #define FLAG_TRANSITORY 12	/* GPIO may lose value in sleep or reset */
+#define FLAG_PULLUP	13	/* Gpio drive is resistive pullup */
+#define FLAG_PULLDOWN	14	/* Gpio drive is resistive pulldown */
+#define FLAG_STRONG	15	/* Gpio drive is strong (fast output) */
+#define FLAG_HIZ	16	/* Gpio drive is Hi-Z (input) */
 
 	/* Connection label */
 	const char		*label;
diff --git a/include/asm-generic/gpio.h b/include/asm-generic/gpio.h
index 19eadac415c4..4cbba8308161 100644
--- a/include/asm-generic/gpio.h
+++ b/include/asm-generic/gpio.h
@@ -81,6 +81,11 @@ static inline int gpio_set_debounce(unsigned gpio, unsigned debounce)
 	return gpiod_set_debounce(gpio_to_desc(gpio), debounce);
 }
 
+static inline int gpio_set_drive(unsigned gpio, unsigned mode)
+{
+	return gpiod_set_drive(gpio_to_desc(gpio), mode);
+}
+
 static inline int gpio_get_value_cansleep(unsigned gpio)
 {
 	return gpiod_get_raw_value_cansleep(gpio_to_desc(gpio));
diff --git a/include/linux/gpio.h b/include/linux/gpio.h
index b3115d1a7d49..0dcea09debd5 100644
--- a/include/linux/gpio.h
+++ b/include/linux/gpio.h
@@ -41,6 +41,11 @@
 #define GPIOF_EXPORT_DIR_FIXED	(GPIOF_EXPORT)
 #define GPIOF_EXPORT_DIR_CHANGEABLE (GPIOF_EXPORT | GPIOF_EXPORT_CHANGEABLE)
 
+#define GPIOF_DRIVE_PULLUP	(1 << 7)
+#define GPIOF_DRIVE_PULLDOWN	(1 << 8)
+#define GPIOF_DRIVE_STRONG	(1 << 9)
+#define GPIOF_DRIVE_HIZ		(1 << 10)
+
 /**
  * struct gpio - a structure describing a GPIO with configuration
  * @gpio:	the GPIO number
@@ -159,6 +164,11 @@ static inline int gpio_set_debounce(unsigned gpio, unsigned debounce)
 	return -ENOSYS;
 }
 
+static inline int gpio_set_drive(unsigned gpio, unsigned mode)
+{
+	return -ENOSYS;
+}
+
 static inline int gpio_get_value(unsigned gpio)
 {
 	/* GPIO can never have been requested or set as {in,out}put */
diff --git a/include/linux/gpio/consumer.h b/include/linux/gpio/consumer.h
index 8dfd8300d9c3..5ee083d80843 100644
--- a/include/linux/gpio/consumer.h
+++ b/include/linux/gpio/consumer.h
@@ -136,6 +136,7 @@ int gpiod_set_raw_array_value_cansleep(unsigned int array_size,
 					int *value_array);
 
 int gpiod_set_debounce(struct gpio_desc *desc, unsigned debounce);
+int gpiod_set_drive(struct gpio_desc *desc, unsigned mode);
 int gpiod_set_transitory(struct gpio_desc *desc, bool transitory);
 
 int gpiod_is_active_low(const struct gpio_desc *desc);
@@ -445,6 +446,15 @@ static inline int gpiod_set_transitory(struct gpio_desc *desc, bool transitory)
 	return -ENOSYS;
 }
 
+
+static inline int gpiod_set_drive(unsigned gpio, unsigned mode)
+{
+	/* GPIO can never have been requested */
+	WARN_ON(1);
+	return -ENOSYS;
+}
+
+
 static inline int gpiod_is_active_low(const struct gpio_desc *desc)
 {
 	/* GPIO can never have been requested */
diff --git a/include/linux/gpio/driver.h b/include/linux/gpio/driver.h
index a4d5eb37744a..8859fb798b57 100644
--- a/include/linux/gpio/driver.h
+++ b/include/linux/gpio/driver.h
@@ -258,6 +258,8 @@ struct gpio_chip {
 	int			(*set_config)(struct gpio_chip *chip,
 					      unsigned offset,
 					      unsigned long config);
+	int			(*set_drive)(struct gpio_chip *chip,
+						unsigned offset, unsigned mode);
 	int			(*to_irq)(struct gpio_chip *chip,
 						unsigned offset);
 
-- 
2.25.1

